"""This module only exist so we can have extension classes that derive from
the interpreted classes in ``setuptools``
(otherwise it would not be possible to compile ``mypyc/build.py``).

The classes defined here are not very clever and should as much as
possible just delegate to ``mypyc/build.py``'s compiled functions.
"""
import sys
from typing_extensions import TypeAlias

from mypy.fscache import FileSystemCache
from mypy.options import Options
from mypyc.codegen.emitmodule import Group
from mypyc.options import CompilerOptions

__all__ = [
    "Extension",  # re-export so we can use it in other files
    "_MypycBaseExtension",
    "_MypycExtension",
    "_MypycShim",
    "_PREPROCESSING_SUPPORTED",
]


try:
    # First of all, import setuptools so that it monkey-patch overrides distutils
    import setuptools  # noqa: F401
except ImportError:
    pass


# mypy: follow-imports=silent
# mypy: disallow-any-unimported=false


if sys.version_info < (3, 12):
    from distutils.command.build_ext import build_ext as BuildExt
    from distutils.core import Extension  # monkey-patched by setuptools
else:
    from setuptools import Extension
    from setuptools.command.build_ext import build_ext as BuildExt


_base_Extension: TypeAlias = Extension

try:
    from setuptools.extension import PreprocessedExtension  # type: ignore[attr-defined]

    _base_Extension = PreprocessedExtension  # type: ignore[misc]
    _PREPROCESSING_SUPPORTED = True
except ImportError:
    _PREPROCESSING_SUPPORTED = False


class _MypycBaseExtension(_base_Extension):
    def _preprocess_deferred(self) -> Extension:
        raise NotImplementedError

    def preprocess(self, _build_ext: BuildExt) -> Extension:
        """Hook that will be called just before each extension's compilation."""
        return self._preprocess_deferred()


class _MypycExtension(_MypycBaseExtension):
    """
    If the user specifies multiple Python files at once,
    this creates one shared library extension module that all of the others import.
    The shared library (which is named by the ``group``'s name) is a python
    extension module that exports the real initialization functions in
    Capsules stored in module attributes.

    If the user specifies a single module, there is no need for a shared library
    with shims. Instead, this creates a single extension module.
    """

    def __init__(
        self,
        name: str,
        sources: list[str],
        group: Group,
        options: Options,
        compiler_options: CompilerOptions,
        fscache: FileSystemCache,
        include_dirs: list[str],
        extra_compile_args: list[str],
        skip_cgen_group: list[tuple[str, str]] | None = None,
    ):
        self._group = group
        self._options = options
        self._skip_cgen_group = skip_cgen_group
        self._compiler_options = compiler_options
        self._fscache = fscache
        self._created_files: tuple[list[str], list[str]] | None = None  # sources, deps
        super().__init__(
            name, sources, include_dirs=include_dirs, extra_compile_args=extra_compile_args
        )

    def create_shared_files(self, _build_ext: BuildExt) -> None:
        """Hook that allows creating files before anything else starts to compile."""
        if self._compiler_options.separate:
            # When "separating", we need to generate all files first (one step),
            # before attempting to compile the extension modules (another step).
            # This way one module can depend on header files generated by another one.
            self._created_files = self._create_files()
            # If not separating, the shared library can be pre-processed and compiled
            # in a single step.

    def _preprocess_deferred(self) -> Extension:
        cfilenames, deps = self._created_files or self._create_files()
        return Extension(
            self.name,
            sources=cfilenames,
            include_dirs=self.include_dirs,
            depends=deps,
            extra_compile_args=self.extra_compile_args,
        )

    def _create_files(self) -> tuple[list[str], list[str]]:
        from mypyc.build import _mypyc_create_files  # break circular import

        return _mypyc_create_files(
            self._group,
            self._compiler_options,
            self._options,
            self._fscache,
            self._skip_cgen_group,
        )


class _MypycShim(_MypycBaseExtension):
    """Produce an extension that can be directly imported by the end user.
    This extension does not contain much implementation itself,
    but simply calls an initialization function in the shared library.
    """

    def __init__(
        self,
        name: str,
        sources: list[str],
        group_name: str,
        module: str,
        module_name: str,  # Just the last part
        compiler_options: CompilerOptions,
        extra_compile_args: list[str],
    ):
        self._group_name = group_name
        self._module = module
        self._module_name = module_name
        self._compiler_options = compiler_options

        super().__init__(name, sources, extra_compile_args=extra_compile_args)

    def _preprocess_deferred(self) -> Extension:
        from mypyc.build import generate_c_extension_shim  # break circular import

        build_dir = self._compiler_options.target_dir
        shim_file = generate_c_extension_shim(
            self._module, self._module_name, build_dir, self._group_name
        )

        return Extension(
            self.name, sources=[shim_file], extra_compile_args=self.extra_compile_args
        )
